---
description: 
globs: 
alwaysApply: true
---
# Financial Calculator Development Guidelines

## Development Philosophy
- Write clean, maintainable, and scalable code
- Follow SOLID principles
- Prefer functional and declarative programming patterns over imperative
- Emphasize type safety and static analysis
- Practice component-driven development
- Mobile-first responsive design approach

## Code Implementation Guidelines

### Planning Phase
- Begin with step-by-step planning
- Write detailed pseudocode before implementation
- Document component architecture and data flow
- Consider edge cases and error scenarios

### Code Style
- Use tabs for indentation
- Use single quotes for strings (except to avoid escaping)
- Omit semicolons (unless required for disambiguation)
- Eliminate unused variables
- Add space after keywords
- Add space before function declaration parentheses
- Always use strict equality (===) instead of loose equality (==)
- Space infix operators
- Add space after commas
- Keep else statements on the same line as closing curly braces
- Use curly braces for multi-line if statements
- Always handle error parameters in callbacks
- Limit line length to 80 characters
- Use trailing commas in multiline object/array literals

### Naming Conventions

#### General Rules
- Use PascalCase for:
  - Components
  - Type definitions
  - Interfaces
- Use kebab-case for:
  - Directory names (e.g., components/calculator)
  - File names (e.g., calculator-form.tsx)
- Use camelCase for:
  - Variables
  - Functions
  - Methods
  - Hooks
  - Properties
  - Props
- Use UPPERCASE for:
  - Environment variables
  - Constants (e.g., EXPENSE_CATEGORIES)
  - Global configurations

#### Specific Naming Patterns
- Prefix event handlers with 'handle': handleClick, handleSubmit
- Prefix boolean variables with verbs: isLoading, hasError, canSubmit
- Prefix custom hooks with 'use': useCalculator, useTranslation
- Use complete words over abbreviations except for standard ones

## React Best Practices

### Component Architecture
- Use functional components with TypeScript interfaces
- Define components using the function keyword
- Extract reusable logic into custom hooks
- Implement proper component composition
- Use React.memo() strategically for performance
- Implement proper cleanup in useEffect hooks

### React Performance Optimization
- Use useCallback for memoizing callback functions
- Implement useMemo for expensive computations (especially calculations)
- Avoid inline function definitions in JSX
- Implement proper key props in lists (avoid using index as key)

## TypeScript Implementation
- Enable strict mode
- Define clear interfaces for component props and state
- Use type guards to handle potential undefined or null values safely
- Utilize TypeScript utility types (Partial, Pick, Omit)
- Prefer interface over type for object structures
- Create proper types for expense categories and calculation results

## UI and Styling

### Shadcn UI Components
- Use Shadcn UI components as the base component library
- Customize components using Tailwind CSS
- Apply composition patterns to create modular, reusable components
- Use the cn() utility for conditional classNames

### Tailwind CSS Guidelines
- Design with mobile-first, responsive principles
- Use Tailwind's utility classes for styling
- Define CSS variables for theme colors in globals.css
- Maintain consistent spacing using Tailwind's spacing scale
- Use responsive prefixes (sm:, md:, lg:) for breakpoints

## State Management

### Local State
- Use useState for component-level state
- Implement useReducer for complex state logic
- Use useContext for language preferences
- Implement proper state initialization

### Form Management
- Use React Hook Form for form handling
- Implement Zod for schema validation
- Use proper error messages in Swedish and English
- Handle form submission states properly

## Data Management
- Use localStorage for data persistence
- Implement proper serialization/deserialization
- Handle data migration for version changes
- Create utility functions for storage operations

## Error Handling and Validation

### Form Validation
- Use Zod schemas for type-safe validation
- Implement bilingual error messages
- Show validation errors clearly
- Use proper form field validation

### Error Boundaries
- Implement error boundaries for component failures
- Show user-friendly error messages
- Log errors appropriately

## Testing

### Unit Testing
- Write tests for calculation functions
- Test formatting utilities
- Test validation schemas
- Use Vitest for test runner

### Integration Testing
- Test form submissions
- Test state management
- Test component interactions

## Accessibility (a11y)

### Core Requirements
- Use semantic HTML elements
- Add proper ARIA labels
- Ensure keyboard navigation
- Maintain color contrast ratios
- Provide screen reader support
- Make all interactive elements accessible

## Internationalization (i18n)

### Custom Implementation
- Create translation files for Swedish and English
- Implement language context provider
- Use Swedish as default language
- Format numbers according to Swedish locale
- Format currency as SEK with proper spacing

## Documentation

### Code Documentation
- Use JSDoc for function documentation
- Document complex calculations
- Add comments for business logic
- Document component props with TypeScript

### Project Documentation
- Maintain clear README
- Document setup instructions
- Include usage examples
- Document calculation logic

## File Structure

### Organization
- Group components by feature
- Separate utilities into lib directory
- Keep data files in data directory
- Organize types in dedicated files

## Specific Project Requirements

### Swedish Formatting
- Use space as thousand separator
- Format currency as "X XXX kr"
- Use comma for decimal separator
- Implement proper locale formatting

### Expense Categories
- Maintain hierarchical structure
- Support 13 main categories
- Include all subcategories
- Use TypeScript interfaces for type safety

### Calculations
- Implement accurate financial calculations
- Handle multiple interest rate scenarios
- Calculate proper amortization
- Format results appropriately

## Build and Deployment

### Next.js Configuration
- Use App Router
- Enable TypeScript strict mode
- Configure path aliases (@/*)
- Optimize for production builds

### Performance
- Optimize bundle size
- Implement code splitting where needed
- Use dynamic imports for heavy components
- Monitor performance metrics